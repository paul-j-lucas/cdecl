cdecl> help
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help cast
command:
  cast [<name>] {as|[in]to} <english>
cdecl> help command
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help commands
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help declare
command:
  declare <name> [, <name>]* as <english> [<declare-option>]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
cdecl> help define
command:
  define <name> as <english>
cdecl> help english
english:
  <store>* <ar-qual>* array [<number>|<name>|*] of <english>
  <store>* <ar-qual>* variable [length] array of <english>
  <store>* function [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to <english>
  { enum | struct | union } <name>
  block [([<args>])] [returning <english>]
  <store>* <modifier>* [<C-type>]
ar-qual: non-empty | const | restrict | volatile
args: a comma separated list of [<name> as] <english>
C-type: auto | _BitInt(<number>) | bool | char[{8|16|32}_t] | wchar_t | int |
        float | double | void
cv-qual: _Atomic | const | restrict | volatile
modifier: complex | imaginary | short | long | signed | unsigned | <cv-qual>
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
store: constexpr | extern | register | static | thread_local | typedef
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help exit
command:
  exit | q[uit]
cdecl> help explain
command:
  explain <gibberish> [, <gibberish>]*
cdecl> help include
command:
  [#]include "<path>"
cdecl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help quit
command:
  exit | q[uit]
cdecl> help set
command:
  set [<option> [= <value>] | options | <lang>]*
cdecl> help show
command:
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
cdecl> help struct
command:
cdecl> help typedef
command:
  type[def] <gibberish> [, <gibberish>]*
cdecl> help union
command:
cdecl> 
cdecl> set knr
cdecl> help
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name>
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help command
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name>
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help commands
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name>
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help english
english:
  <store>* array [<number>|<name>] of <english>
  <store>* function [([<args>])] [returning <english>]
  <store>* pointer to <english>
  { struct | union } <name>
  block [([<args>])] [returning <english>]
  <store>* <modifier>* [<C-type>]
args: a comma separated list of <name>
C-type: char | int | float | double
modifier: short | long | unsigned
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
store: auto | extern | register | static | typedef
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> 
cdecl> set c89
cdecl> help
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name>
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help command
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name>
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help commands
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name>
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help english
english:
  <store>* array [<number>|<name>] of <english>
  <store>* function [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to <english>
  { enum | struct | union } <name>
  block [([<args>])] [returning <english>]
  <store>* <modifier>* [<C-type>]
args: a comma separated list of <name>, <english>, or <name> as <english>
C-type: char | int | float | double | void
cv-qual: const | volatile
modifier: short | long | signed | unsigned | <cv-qual>
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
store: auto | extern | register | static | typedef
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> 
cdecl> set c95
cdecl> help
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name>
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help command
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name>
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help commands
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name>
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help english
english:
  <store>* array [<number>|<name>] of <english>
  <store>* function [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to <english>
  { enum | struct | union } <name>
  block [([<args>])] [returning <english>]
  <store>* <modifier>* [<C-type>]
args: a comma separated list of <name>, <english>, or <name> as <english>
C-type: char | wchar_t | int | float | double | void
cv-qual: const | volatile
modifier: short | long | signed | unsigned | <cv-qual>
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
store: auto | extern | register | static | typedef
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> 
cdecl> set c99
cdecl> help
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help command
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help commands
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help english
english:
  <store>* <ar-qual>* array [<number>|<name>|*] of <english>
  <store>* <ar-qual>* variable [length] array of <english>
  <store>* function [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to <english>
  { enum | struct | union } <name>
  block [([<args>])] [returning <english>]
  <store>* <modifier>* [<C-type>]
ar-qual: non-empty | const | restrict | volatile
args: a comma separated list of <name>, <english>, or <name> as <english>
C-type: _Bool | char | wchar_t | int | float | double | void
cv-qual: const | restrict | volatile
modifier: complex | imaginary | short | long | signed | unsigned | <cv-qual>
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
store: auto | extern | register | static | typedef
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> 
cdecl> set c11
cdecl> help
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help command
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help commands
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help english
english:
  <store>* <ar-qual>* array [<number>|<name>|*] of <english>
  <store>* <ar-qual>* variable [length] array of <english>
  <store>* function [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to <english>
  { enum | struct | union } <name>
  block [([<args>])] [returning <english>]
  <store>* <modifier>* [<C-type>]
ar-qual: non-empty | const | restrict | volatile
args: a comma separated list of <name>, <english>, or <name> as <english>
C-type: _Bool | char[{16|32}_t] | wchar_t | int | float | double | void
cv-qual: _Atomic | const | restrict | volatile
modifier: complex | imaginary | short | long | signed | unsigned | <cv-qual>
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
store: auto | extern | register | static | _Thread_local | typedef
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> 
cdecl> set c17
cdecl> help
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help command
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help commands
command:
  cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  #undef <name>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C declaration, like "int x"; or a cast, like "(int)x"
glob: a <name> containing zero or more literal *
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help english
english:
  <store>* <ar-qual>* array [<number>|<name>|*] of <english>
  <store>* <ar-qual>* variable [length] array of <english>
  <store>* function [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to <english>
  { enum | struct | union } <name>
  block [([<args>])] [returning <english>]
  <store>* <modifier>* [<C-type>]
ar-qual: non-empty | const | restrict | volatile
args: a comma separated list of <name>, <english>, or <name> as <english>
C-type: _Bool | char[{16|32}_t] | wchar_t | int | float | double | void
cv-qual: _Atomic | const | restrict | volatile
modifier: complex | imaginary | short | long | signed | unsigned | <cv-qual>
name: a C identifier
number: a binary, octal, decimal, or hexadecimal integer
store: auto | extern | register | static | _Thread_local | typedef
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
cdecl> 
cdecl> set c++
c++decl> help
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help class
command:
  class <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
c++decl> help command
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help commands
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help const
command:
  const cast [<name>] {as|[in]to} <english>
c++decl> help const  cast
command:
  const cast [<name>] {as|[in]to} <english>
c++decl> help const cast
command:
  const cast [<name>] {as|[in]to} <english>
c++decl> help declare
command:
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
c++decl> help dynamic
command:
  dynamic cast [<name>] {as|[in]to} <english>
c++decl> help dynamic cast
command:
  dynamic cast [<name>] {as|[in]to} <english>
c++decl> help english
english:
  <store>* <cv-qual>* array [<number>] of <english>
  <cv-qual>* concept <name> [parameter pack]
  <store>* constructor [([<args>])]
  [virtual] destructor [()]
  <store>* <fn-qual>* [[non-]member] function [([<args>])] [returning <english>]
  <store>* <fn-qual>* [[non-]member] operator [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to [member of { class | struct } <name>] <english>
  { enum [class|struct] [of [type] <english>] | class | struct | union } <name>
  <store>* [rvalue] reference to <english>
  structured binding
  <store>* <modifier>* [<C++-type>]
lambda-english:
  [[capturing] [[<captures>]] [([<args>])] [returning <english>]
user-defined-english:
  conversion [operator] [of <scope-e> <name>]* returning <english>
  literal [([<args>])] [returning <english>]
args: a comma separated list of [<name> as] <english>
captures: [<capture-default>,] [[&]<name>][,[&]<name>]*
capture-default: {copy|reference} [by] default | = | &
C++-type: auto | bool | char[{8|16|32}_t] | wchar_t | int | float | double |
          parameter pack | void
cv-qual: const | volatile
fn-qual: <cv-qual> | [rvalue] reference
modifier: short | long | signed | unsigned | <cv-qual>
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
store: const[eval|expr|init] | explicit | extern ["C" [linkage]] | friend |
       mutable | static | this | thread_local | typedef | [pure] virtual
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help inline
command:
  inline namespace <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
c++decl> help namespace
command:
  namespace <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
c++decl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help reinterpret
command:
  reinterpret cast [<name>] {as|[in]to} <english>
c++decl> help reinterpret cast
command:
  reinterpret cast [<name>] {as|[in]to} <english>
c++decl> help show
command:
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
c++decl> help static
command:
  static cast [<name>] {as|[in]to} <english>
c++decl> help static cast
command:
  static cast [<name>] {as|[in]to} <english>
c++decl> help using
command:
  using <name> = <gibberish>
c++decl> 
c++decl> set c++98
c++decl> help
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  declare <operator> as <english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> } ;]* }]
  #undef <name>
  exit | q[uit]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help command
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  declare <operator> as <english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> } ;]* }]
  #undef <name>
  exit | q[uit]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help commands
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  declare <operator> as <english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> } ;]* }]
  #undef <name>
  exit | q[uit]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help english
english:
  <store>* <cv-qual>* array [<number>] of <english>
  <cv-qual>* concept <name> [parameter pack]
  <store>* constructor [([<args>])]
  [virtual] destructor [()]
  <store>* <fn-qual>* [[non-]member] function [([<args>])] [returning <english>]
  <store>* <fn-qual>* [[non-]member] operator [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to [member of { class | struct } <name>] <english>
  { enum | class | struct | union } <name>
  <store>* reference to <english>
  <store>* <modifier>* [<C++-type>]
user-defined-english:
  conversion [operator] [of <scope-e> <name>]* returning <english>
args: a comma separated list of [<name> as] <english>
C++-type: bool | char | wchar_t | int | float | double | void
cv-qual: const | volatile
fn-qual: <cv-qual>
modifier: short | long | signed | unsigned | <cv-qual>
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
scope-c: class | struct | union | namespace
scope-e: <scope-c> | scope
store: auto | const | explicit | extern ["C" [linkage]] | friend |
       mutable | static | typedef | [pure] virtual
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> 
c++decl> set c++03
c++decl> help
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  declare <operator> as <english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> } ;]* }]
  #undef <name>
  exit | q[uit]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help command
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  declare <operator> as <english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> } ;]* }]
  #undef <name>
  exit | q[uit]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help commands
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [width <number> [bits]]
  declare <operator> as <english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> } ;]* }]
  #undef <name>
  exit | q[uit]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help english
english:
  <store>* <cv-qual>* array [<number>] of <english>
  <cv-qual>* concept <name> [parameter pack]
  <store>* constructor [([<args>])]
  [virtual] destructor [()]
  <store>* <fn-qual>* [[non-]member] function [([<args>])] [returning <english>]
  <store>* <fn-qual>* [[non-]member] operator [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to [member of { class | struct } <name>] <english>
  { enum | class | struct | union } <name>
  <store>* reference to <english>
  <store>* <modifier>* [<C++-type>]
user-defined-english:
  conversion [operator] [of <scope-e> <name>]* returning <english>
args: a comma separated list of [<name> as] <english>
C++-type: bool | char | wchar_t | int | float | double | void
cv-qual: const | volatile
fn-qual: <cv-qual>
modifier: short | long | signed | unsigned | <cv-qual>
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
scope-c: class | struct | union | namespace
scope-e: <scope-c> | scope
store: auto | const | explicit | extern ["C" [linkage]] | friend |
       mutable | static | typedef | [pure] virtual
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> 
c++decl> set c++11
c++decl> help
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help command
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help commands
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help english
english:
  <store>* <cv-qual>* array [<number>] of <english>
  <cv-qual>* concept <name> [parameter pack]
  <store>* constructor [([<args>])]
  [virtual] destructor [()]
  <store>* <fn-qual>* [[non-]member] function [([<args>])] [returning <english>]
  <store>* <fn-qual>* [[non-]member] operator [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to [member of { class | struct } <name>] <english>
  { enum [class|struct] [of [type] <english>] | class | struct | union } <name>
  <store>* [rvalue] reference to <english>
  <store>* <modifier>* [<C++-type>]
lambda-english:
  [[capturing] [[<captures>]] [([<args>])] [returning <english>]
user-defined-english:
  conversion [operator] [of <scope-e> <name>]* returning <english>
  literal [([<args>])] [returning <english>]
args: a comma separated list of [<name> as] <english>
captures: [<capture-default>,] [[&]<name>][,[&]<name>]*
capture-default: {copy|reference} [by] default | = | &
C++-type: auto | bool | char[{16|32}_t] | wchar_t | int | float | double | void
cv-qual: const | volatile
fn-qual: <cv-qual> | [rvalue] reference
modifier: short | long | signed | unsigned | <cv-qual>
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
store: const[expr] | explicit | extern ["C" [linkage]] | friend |
       mutable | static | thread_local | typedef | [pure] virtual
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> 
c++decl> set c++14
c++decl> help
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help command
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help commands
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help english
english:
  <store>* <cv-qual>* array [<number>] of <english>
  <cv-qual>* concept <name> [parameter pack]
  <store>* constructor [([<args>])]
  [virtual] destructor [()]
  <store>* <fn-qual>* [[non-]member] function [([<args>])] [returning <english>]
  <store>* <fn-qual>* [[non-]member] operator [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to [member of { class | struct } <name>] <english>
  { enum [class|struct] [of [type] <english>] | class | struct | union } <name>
  <store>* [rvalue] reference to <english>
  <store>* <modifier>* [<C++-type>]
lambda-english:
  [[capturing] [[<captures>]] [([<args>])] [returning <english>]
user-defined-english:
  conversion [operator] [of <scope-e> <name>]* returning <english>
  literal [([<args>])] [returning <english>]
args: a comma separated list of [<name> as] <english>
captures: [<capture-default>,] [[&]<name>][,[&]<name>]*
capture-default: {copy|reference} [by] default | = | &
C++-type: auto | bool | char[{16|32}_t] | wchar_t | int | float | double | void
cv-qual: const | volatile
fn-qual: <cv-qual> | [rvalue] reference
modifier: short | long | signed | unsigned | <cv-qual>
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
store: const[expr] | explicit | extern ["C" [linkage]] | friend |
       mutable | static | thread_local | typedef | [pure] virtual
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> 
c++decl> set c++17
c++decl> help
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help command
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help commands
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help english
english:
  <store>* <cv-qual>* array [<number>] of <english>
  <cv-qual>* concept <name> [parameter pack]
  <store>* constructor [([<args>])]
  [virtual] destructor [()]
  <store>* <fn-qual>* [[non-]member] function [([<args>])] [returning <english>]
  <store>* <fn-qual>* [[non-]member] operator [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to [member of { class | struct } <name>] <english>
  { enum [class|struct] [of [type] <english>] | class | struct | union } <name>
  <store>* [rvalue] reference to <english>
  structured binding
  <store>* <modifier>* [<C++-type>]
lambda-english:
  [[capturing] [[<captures>]] [([<args>])] [returning <english>]
user-defined-english:
  conversion [operator] [of <scope-e> <name>]* returning <english>
  literal [([<args>])] [returning <english>]
args: a comma separated list of [<name> as] <english>
captures: [<capture-default>,] [[&]<name>][,[&]<name>]*
capture-default: {copy|reference} [by] default | = | &
C++-type: auto | bool | char[{16|32}_t] | wchar_t | int | float | double | void
cv-qual: const | volatile
fn-qual: <cv-qual> | [rvalue] reference
modifier: short | long | signed | unsigned | <cv-qual>
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
store: const[expr] | explicit | extern ["C" [linkage]] | friend |
       mutable | static | thread_local | typedef | [pure] virtual
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> 
c++decl> set c++20
c++decl> help
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help command
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help commands
command:
  [const | dynamic | reinterpret | static] cast [<name>] {as|[in]to} <english>
  declare <name> [, <name>]* as <english> [<declare-option>]
  declare <operator> as <english>
  declare [<english>] lambda <lambda-english>
  declare [<english>] user-def[ined] <user-defined-english>
  define <name> as <english>
  #define <name>[([<pp-param> [, <pp-param>]*])] <pp-token>*
  expand <name>[([<pp-token>* [, <pp-token>*]*])] <pp-token>*
  explain <gibberish> [, <gibberish>]*
  { help | ? } [command[s] | <command> | english | options]
  [#]include "<path>"
  set [<option> [= <value>] | options | <lang>]*
  show [<name>|[all] [predefined|user] [<glob>]] [[as] {english|typedef|using}]
  show {<name>|[predefined|user] macros}
  type[def] <gibberish> [, <gibberish>]*
  <scope-c> <name> [{ [{ <scope-c> | <typedef> | <using> } ;]* }]
  #undef <name>
  using <name> = <gibberish>
  exit | q[uit]
declare-option:
  align[ed] [as|to] {<number> [bytes] | <english>}
  width <number> [bits]
gibberish: a C++ declaration, like "int x"; or a cast, like "(int)x"
glob: a [**::]<name>[::<name>]* containing zero or more literal *
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
pp-param: a macro parameter <name> or ...
pp-token: a preprocessor token
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help english
english:
  <store>* <cv-qual>* array [<number>] of <english>
  <cv-qual>* concept <name> [parameter pack]
  <store>* constructor [([<args>])]
  [virtual] destructor [()]
  <store>* <fn-qual>* [[non-]member] function [([<args>])] [returning <english>]
  <store>* <fn-qual>* [[non-]member] operator [([<args>])] [returning <english>]
  <store>* <cv-qual>* pointer to [member of { class | struct } <name>] <english>
  { enum [class|struct] [of [type] <english>] | class | struct | union } <name>
  <store>* [rvalue] reference to <english>
  structured binding
  <store>* <modifier>* [<C++-type>]
lambda-english:
  [[capturing] [[<captures>]] [([<args>])] [returning <english>]
user-defined-english:
  conversion [operator] [of <scope-e> <name>]* returning <english>
  literal [([<args>])] [returning <english>]
args: a comma separated list of [<name> as] <english>
captures: [<capture-default>,] [[&]<name>][,[&]<name>]*
capture-default: {copy|reference} [by] default | = | &
C++-type: auto | bool | char[{8|16|32}_t] | wchar_t | int | float | double |
          parameter pack | void
cv-qual: const | volatile
fn-qual: <cv-qual> | [rvalue] reference
modifier: short | long | signed | unsigned | <cv-qual>
name: a C++ identifier: <name>[::<name>]* | <name> [of <scope-e> <name>]*
number: a binary, octal, decimal, or hexadecimal integer
scope-c: class | struct | union | [inline] namespace
scope-e: <scope-c> | scope
store: const[eval|expr|init] | explicit | extern ["C" [linkage]] | friend |
       mutable | static | thread_local | typedef | [pure] virtual
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
c++decl> help options
option:
  [no]alt-tokens
  [no]debug[={{u}+|*|-}]
  [no]east-const
  [no]echo-commands
  [no]english-types
  [no]explicit-ecsu[={{ecsu}+|*|-}]
  [no]explicit-int[={<types>|*|-}]
  {di|tri|no}graphs
  [no]infer-command
  lang=<lang>
  <lang>
  [no]prompt
  [no]semicolon
  [no]trailing-return
  [no]using
  [no]west-decl[={{bflostr}+|*|-}]
lang:
  K[&|N]R[C] | C[K[&|N]R|78|89|95|99|11|17|23] | C++[98|03|11|14|17|20|23]
types:
  i|u|[u]{i|s|l[l]}[,[u]{i|s|l[l]}]*
where: [] = 0 or 1; * = 0 or more; + = 1 or more; {} = one of; | = alternate
